# TD-автомат: инварианты, леммы корректности и масштабирование deps-графа

Этот документ — «доказательная дорожная карта» к реализованной схеме TD (v3.4+) и параллельный план
масштабирования от 1D/кольца к общему deps-графу.

## 1. Модель и обозначения

- Зона `z` имеет **временной слой** `step_id(z)` и состояние автомата (`F,P,D,W,S,...`).
- `A(z)` — множество атомов во владении зоны `z` (ownership), т.е. `atom_ids`.
- `H(z)` — множество halo/ghost для таблиц/сил, т.е. `halo_ids` при `halo_step_id==step_id`.
- `deps_table(z)` — зоны, пересекающие p-окрестность `[z0-cutoff, z1+cutoff]` (в v2.8+).
- `deps_owner(z)` — зоны, пересекающие `[z0-buffer, z1+buffer]` (в v3.3+) — потенциальные приёмники миграции.
- `support(table(z))` — опора таблицы взаимодействия зоны `z`.

## 2. Инварианты безопасности (safety)

### I1. Разделение владения и halo
Для любого `z`:
- `A(z)` участвует в интегрировании,
- `H(z)` участвует только в построении таблиц/сил,
- интегрирование **не меняет** координаты/скорости halo как отдельного владения (halo — копия).

Практическая проверка: операции обновления `r/v` выполняются по `ids`, но миграция/владение меняет только `atom_ids`.

### I2. Однослойность halo
`halo_step_id(z) == step_id(z)` — необходимое условие учёта halo в таблицах.
Иначе halo игнорируется в `ensure_table`.

Следствие: нет «протекания» halo между слоями времени.

### I3. Табличная корректность halo (support-driven)
Передача halo должна удовлетворять:
`H_sent(sender→z) ⊆ support(table(z))`
(в v2.6+ добавлен счётчик `hV` — violations).

### I4. Геометрическая локальность halo
`H(z) ⊆ p-neighborhood(z)` (v2.5+; счётчик `hG`).

### I5. Готовность W по deps_table
Если `require_table_deps=true`, то вход в `W` допустим только если для всех `d∈deps_table(z)` локально представлены данные (`ztype(d) != F`).
(через shadow zones v3.1+).

Это «формальное ядро корректности»: вычисление не стартует без входных данных.

### I6. Корректная маршрутизация миграций по owner-deps
Если `require_owner_deps=true`, то для всех `d∈deps_owner(z)` известен держатель `holder_map[d] != -1`.
Если `require_owner_ver=true`, то `holder_ver[d]` достаточно свежий относительно окна `2*max_step_lag+2`.

Это минимальная гарантия «не отправить миграцию в никуда» при direct routing.

## 3. Леммы (протокол → инварианты)

### L1. (I2) следует из политики приёма/очистки halo
Поскольку при смене `step_id` halo замещается, и в таблицы включается только при `halo_step_id==step_id`, halo не может быть использован на чужом слое.

### L2. (I3) поддерживается конструкцией overlap
Поскольку в TD-отправке halo строится из overlap:
`overlap = A(sender) ∩ support(table(receiver))`,
а далее (опционально) режется p-фильтром, итоговый halo остаётся подмножеством опоры.

### L3. (I5) обеспечивается shadow promotion + REQ_HALO
Если deps не представлены, ранг может вытянуть `DELTA_HALO` через `REQ_HALO`, что создаёт shadow `P`.
Следовательно, при отсутствии сетевых потерь система прогрессирует к удовлетворению `deps_table`.

## 4. Корректность прогресса (liveness)

Требует предположений:
- каналы доставки надёжны (нет потерь),
- есть справедливость планировщика (batch/очереди не голодают),
- `REQ_HALO/REQ_HOLDER` не подавляются бесконечно.

Тогда:
- зоны в состоянии `D` рано или поздно удовлетворяют deps-готовности и входят в `W`,
- `holder_map` сходится благодаря gossip/pull.

## 5. Масштабирование на общий deps-граф (не 1D/кольцо)

Текущая реализация 1D использует геометрию для `deps_zone_ids`.
Для общего случая нужно:

### S1. Абстракция `DepsProvider`
Интерфейс:
- `deps_table(zid) -> list[dep_zid]`
- `deps_owner(zid) -> list[dep_zid]`
- `owner(dep_zid) -> rank`
- `geom_info(dep_zid)` (для p-фильтра halo).

Реализация:
- доменная декомпозиция в 3D,
- соседние блоки (26 соседей) + PBC,
- расширение p-окрестности на `cutoff` и owner-окрестности на `buffer`.

### S2. Адресная маршрутизация
Вместо 1D ring:
- `send` на `owner(dep_zid)` напрямую.
`holder_map` остаётся, но теперь статически из разбиения (или динамически при миграции зон по времени, если она сохраняется).

### S3. Табличная опора в общем графе
`support(table(z))` строится из:
- локальных `A(z)`,
- halo от всех deps_table(z).

Критично: гарантировать, что каждое ребро deps имеет механизм доставки halo.

### S4. Доказательная часть
Для публикации:
- Формальная спецификация состояний автомата (перечень переходов + условия),
- Доказательства I1–I6 по индукции по шагам,
- Леммы прогресса при fairness (и при включённых REQ).

## 6. Связь с тестовым стендом

`verifylab` и `golden-check` должны проверять:
- I1/I2 косвенно через совпадение траекторий,
- I3/I4 напрямую через счётчики нарушений (`hV,hG`),
- I5/I6 через стресс-режим (chaos), где порядок применения сообщений рандомизирован.

Рекомендуемая «публикабельная» таблица:
- worst-case `max|dE|,max|dP|` по свипу,
- частота нарушений `hG/hV`,
- частота блокировок `wT,wO,wOU,wOS` и эффективность `REQ` (reqS/reqR/reqHS/reqHR).


## 8. v4.3: 3D формулировки I3/I4 (AABB)

- I4(3D): `H(z)` должно лежать в AABB зоны `z`, расширенном на `cutoff` (по каждой оси, с PBC).
- I3(3D): `H(z) ⊆ support(table(z))`, где support задаётся `candidate_ids` таблицы.

В коде это проверяется счётчиками `hG3` (геометрические нарушения halo) и `hV3` (halo вне support set),
а также `tG3` (candidate_ids таблицы вне AABB-support, что указывает на ошибку построения support).
