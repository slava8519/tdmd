# Аналитический отчёт о текущем состоянии и плане развития TDMD‑TD (v1.4)

## Текущее состояние TDMD‑TD v1.4

### Общая картина реализованного ядра
По состоянию на **v1.4** TDMD‑TD представляет собой минимальный, но уже функциональный MD‑движок (классическая МД) с интегрированием **velocity‑Verlet** и периодическими граничными условиями (PBC). Velocity‑Verlet широко используется в молекулярной динамике благодаря хорошей долгосрочной устойчивости и симплектичности (в гамильтоновых системах), что делает его стандартной опорной схемой для верификации интегратора. citeturn23search12turn23search20

Параллелизация реализуется через **TD‑схему на “зонах”** с обменом зон между MPI‑процессами, при этом зона — это пространственный срез системы (в текущей реализации — вдоль оси *z*) и связанная с ним подмножина атомов. Само разбиение модели вдоль координатной оси на расчётные зоны и конвейерная логика расчёта зон соответствует формулировкам, встречающимся в диссертационных/преддиссертационных материалах по **методу декомпозиции времени** (в частности упоминается разбиение на зоны вдоль *Z* и иллюстрация на рисунке). citeturn18search0

Ниже — точная фиксация статуса четырёх ключевых пунктов плана, о которых вы просили (верификация, зональные Verlet‑листы, MPI‑обмен зон, EAM).

### Строгая верификация: что сделано, а что пока лишь в зачатке
**Сделано в v1.4:**
- Есть режим `verify`, который сравнивает **serial‑эталон** и **td_local** по метрикам:
  - `max|dr|` — максимум по атомам нормы разности координат,
  - `max|dv|` — максимум по атомам нормы разности скоростей,
  после заданного числа шагов.
- Есть отдельный “serial reference” решатель (последовательный) и отдельный “td_local” решатель (однопроцессный TD без MPI), что создаёт основу корректной пирамиды тестирования: **serial → td_local → td_full_mpi**.

**Не сделано (по критериям “строгой” верификации):**
- В `verify` **не сравниваются** энергия (полная/кинетическая/потенциальная), температура, давление, импульс, дрейф энергии во времени, статистики распределений, и нет стандартного набора тест‑кейсов (кристалл/газ/жидкость).
- Сравнение координат в текущем виде не учитывает периодичность (минимальный образ для ошибки координат), что может давать ложные “большие ошибки” при перескоке через границу PBC (это типичная ловушка в тестах МД).

**Вывод:** реализована **базовая (“легковесная”) верификация корректности траекторий**, но **строгая верификация** (как научно‑обоснованный регламент) пока **не завершена** и должна быть расширена до стандартов MD‑валидации (см. раздел “Строгая верификация…” ниже). Для строгой верификации полезно опираться на общепринятые ориентиры: контроль дрейфа энергии для выбора шага интегрирования и устойчивости, а также корректные формулы температуры/давления/вириала. citeturn23search28turn24search1

### Зональные Verlet‑листы: что реализовано к v1.4
**Сделано в v1.4:**
- Реализована зональная структура ускорения поиска соседей в виде **локальных “bins/cells”** и кэша, привязанного к зоне:
  - строится разбиение по **x,y** глобально‑периодическое;
  - по **z** — локальное, привязанное к зоне;
  - поддерживается несколько шагов без полной перестройки при выполнении критерия смещения.
- В зоне используются **persist‑кэши** (перестройка не каждый шаг), что эквивалентно идее Verlet‑буфера/“skin”: список соседей (или его прокси‑структура) можно переиспользовать, пока частицы не сместились “слишком сильно”. Практика перестройки по условию “смещение больше половины skin” — стандартный подход в МД и прямо отражён в документации LAMMPS (и в общем понимании Verlet‑подхода). citeturn25search0turn25search15
- Специфическое улучшение v1.4: устранён “fallback” к глобальному z‑разбиению; вместо этого реализован **unwrapped‑интервал по z** для зон, пересекающих PBC‑границу. Это важно, потому что локальность по z является ключевой предпосылкой эффективности зональных структур.

**Смысл научно/технически:** текущая реализация — это уже не “классический Verlet list per atom”, а **зонально‑локальный гибрид** (linked‑cells по зоне + skin‑условие для обновления). Такой подход хорошо согласуется с практиками ускорения короткодействующих сил (классика: linked‑cell + Verlet‑skin). citeturn25search32turn25search2

### MPI‑архитектура обмена зонами: что реализовано к v1.4
**Сделано в v1.4 (в терминах архитектуры):**
- Реализован режим `td_full_mpi` на `mpi4py` с передачей “зон” по кольцу `prev_rank ↔ next_rank`.
- Есть **режимы старта распределения зон**, включая важный для TD‑конвейера режим `scatter_zones` (каждый rank получает начальный пакет зон).
- Реализован “fast_sync” и “strict_fast_sync”: строгая проверка предпосылок конвейера вида `zones_total = 2P` и конкретного режима старта. Само требование вида **2P** как параметризации конвейера встречается в диссертационных материалах по теме (встречается конструкция “2p” в контексте разбиения на расчётные зоны и дальнейшей логики). citeturn28search2
- Коммуникации построены так, чтобы избегать взаимной блокировки: используется разделение порядка `send/recv` по чётности ранга (типичный приём для кольцевых обменов).
- Есть механизм “overlap/halo‑фильтрации” при отправке: часть атомов **удерживается** в зоне, если они требуются следующей зоне для её радиуса взаимодействия (используется вычисление перекрытия через локальную структуру соседей). Это приближает поведение к “призрачным” атомам (ghost atoms) в классической пространственной декомпозиции, хотя реализовано через TD‑обмен зон.

**Что это даёт:** формируется **рабочий прототип TD‑конвейера**, где зоны “переезжают” между процессами, и каждый процесс вычисляет силы/интегрирование для зоны, затем передаёт её дальше.

Для сравнения: в классических MD‑кодах доминирует *пространственная декомпозиция* (domain decomposition) и обмен “ghost atoms”; базовая постановка и мотивировка domain decomposition для короткодействующих потенциалов хорошо изложена в классической статье Плимптона. citeturn25search2
TD‑схема (как в диссертационной постановке) — альтернативная организация вычислений, и текущий TDMD‑TD уже содержит признаки полноценного конвейера по зонам. citeturn18search0turn27search1

### Поддержка EAM: текущий статус
**EAM (Embedded Atom Method) в v1.4 не реализован.**
Присутствуют только простые парные потенциалы (LJ и Morse). Следовательно:
- нет чтения табличных EAM‑файлов;
- нет многочастичной “электронной плотности” и embedding‑энергии;
- нет валидации на металлических решётках и дефектах.

При этом EAM является центральным стандартом для моделирования металлов; классическая постановка EAM дана у Daw & Baskes и в обзорной статье Daw (1993). citeturn23search2turn23search10

## Что остаётся сделать и почему это сложно

### Строгая верификация (научные и инженерные сложности)
Главная сложность строгой верификации — не “посчитать пару чисел”, а построить **систему доказательства корректности** с контролем:
- интегратора (ошибка шага, обратимость/дрейф),
- силового ядра (симметрии, парность, корректность cutoff),
- граничных условий (PBC и minimum image),
- параллельной схемы (эквивалентность serial ↔ td_local ↔ td_full_mpi в пределах ожидаемой численной погрешности).

Даже при идеальной реализации будут расхождения из‑за:
- разного порядка суммирования сил в плавающей точке,
- разного порядка обхода зон/соседей,
- различий момента перестройки neighbor‑структур (Verlet/bin обновления).

Поэтому нужны **метрики стабильности** и **допуски**, а не “бит‑в‑бит” равенство.

### Доведение MPI‑TD до полного TD‑алгоритма из диссертации
Ключевые проблемы:
- **Формализация машины состояний зон.** Сейчас переходы F/D/P/W/S есть, но “размазаны” по коду и завязаны на порядок обхода. В TD‑схеме из диссертации типы зон и их переходы являются частью математически определённого конвейера (в материалах явно фигурируют типы зон и последовательности состояний). citeturn27search1turn18search0
- **Корректность при временных лагах.** Если “настоящий” TD подразумевает, что разные процессы могут быть на разных *временных слоях*, то буфер безопасности должен покрывать не только перемещение за `dt`, но и за максимальный “time lag” между взаимодействующими зонами. Это влияет на формулу буфера, критерии перестройки списков, и вообще на доказательство эквивалентности траектории.
- **Стоимость коммуникаций.** В Python/mpi4py упаковка/распаковка и частые `Iprobe` могут стать доминирующими накладными расходами при росте числа зон и рангов.

### Зональные neighbor‑структуры (Verlet/bin) и их строгое согласование с TD
Сложности:
- В текущем прототипе зональный “neighbor” — это локальные bins + выбор кандидатов. Для полной TD‑схемы нужно, чтобы:
  - перестройка neighbor‑структур была согласована с буфером и графом обмена;
  - существовали **локальные таблицы соседей** (или эквивалент) для разных подсистем: (1) силы зоны, (2) overlap/halo‑решение, (3) возможно — вычисление плотностей (для EAM).
- Нужна строгая гарантия “не пропустить” взаимодействующую пару: стандартный подход — skin и условие перестройки, как у LAMMPS (“half skin displacement”). citeturn25search0turn25search15
Но в TD‑схеме появляются дополнительные источники пропусков: неправильный состав p‑окрестности/кандидатов и рассогласование моментов обновления между зонами.

### EAM (многочастичный потенциал) поверх TD‑схемы
EAM добавляет два слоя сложности:
1) **Алгоритмический:** EAM требует вычисления электронной плотности ρ и embedding‑энергии, что делает силу многочастичной функцией. Классический EAM‑формализм (Daw & Baskes) включает вклад embedding функции и парного члена, а силы зависят от производных embedding‑функции по плотности. citeturn23search2turn23search10
2) **Параллельный/зональный:** чтобы посчитать силу на атом *i*, часто нужно знать ρ не только для *i*, но и для соседей *j* (в зависимости от конкретной формы EAM/FS‑EAM). Это усложняет “что считать локально” и “что держать в halo”.

Кроме того, в EAM обычно используются **табличные файлы** разных форматов (funcfl/setfl/eam.fs/eam.alloy), и нельзя считать реализацию готовой без строгого соответствия формату и интерполяции. Форматы подробно описаны в документации LAMMPS по `pair_style eam` / `eam/alloy` / `eam/fs`. citeturn23search1turn23search9

## Строгая верификация и набор тестов для TDMD‑TD

Ниже — рекомендованный “минимально строгий” протокол, который переводит `verify` из режима “проверка, что не развалилось” в режим **научной валидации**.

### Метрики, которые нужно вводить обязательно
1) **Энергия**
- Кинетическая: \(K=\sum \frac{m v^2}{2}\)
- Потенциальная: \(U\) (сумма по парам/вклад EAM)
- Полная: \(E=K+U\)
- Метрики:
  - относительный дрейф \(\Delta E/E_0\) на NVE,
  - RMS‑флуктуации \(E(t)\) вокруг среднего (должны быть ограничены и не иметь тренда при корректном dt).
Контроль дрейфа энергии — базовый критерий качества интегратора и выбора шага. citeturn23search28turn3search15

2) **Температура**
- По кинетической энергии (с учётом степеней свободы и удаления движения центра масс).
Температура — необходимая метрика для сравнения NVT/NVE режимов и для проверки термостатов (когда они появятся). citeturn23search12turn24search21

3) **Давление / тензор напряжений**
- Для систем с парными силами стандартом является расчёт давления через кинетический вклад и вириал. Практические формулы и разложение по компонентам (pair/bond/kspace/fix) описаны в документации LAMMPS для `compute pressure`. citeturn24search1
Даже если TDMD‑TD не повторяет LAMMPS, использование той же структуры проверки удобно как эталон.

4) **Импульс и движение центра масс**
- Полный импульс \(\sum m v\) (в NVE без внешних сил должен сохраняться).
- Дрейф центра масс (без термостатов/баростатов и без внешних воздействий не должен расти).

5) **Точность совпадения траекторий (serial ↔ td_local ↔ td_full_mpi)**
- Уже есть max|dr|, max|dv|; надо добавить:
  - `RMS(dr)`, `RMS(dv)`,
  - ошибки в энергии: `|E_serial - E_td|`,
  - сравнение по minimum image для координат, чтобы корректно учитывать PBC.

### Тест‑кейсы, которые минимально достаточны для строгой валидации
Набор должен покрывать разные физические режимы и разные “патологии” алгоритма.

**Газ / разреженный режим**
- “Свободные частицы” (нулевой потенциал или очень малое взаимодействие): проверка интегратора и PBC.
- Идеальный газовый режим (очень низкая плотность, LJ/Morse): сравнение давления с \(P \approx \rho k_B T\) как sanity‑check.

**Жидкость (LJ fluid)**
- Стандартный LJ‑флюид в редуцированных единицах (есть множество опубликованных референсных значений плотности/температуры/давления/энергии, удобно брать из классических MD‑источников). Хорошая практика — фиксировать состояние и сравнивать статистики после эквилибрации (средняя энергия, давление, RDF). В качестве методологических ориентиров по статистическим свойствам и устойчивости интегрирования удобно опираться на классические руководства по MD и обсуждения стабильности интегратора. citeturn23search0turn23search32

**Твёрдое тело**
- **FCC** решётка (для LJ или для будущего EAM‑металла): проверка сохранения структуры при малых температурах/малых шагах, проверка “не улетают ли” атомы, проверка того, что давление/энергия не имеют неконтролируемого дрейфа.
- **BCC** решётка: аналогично, плюс тест на корректность геометрии соседей.
- Эти тесты особенно важны для TD‑зон, потому что ошибки “потерянных пар” часто проявляются как медленное разрушение кристалла.

**Дефекты (после внедрения EAM)**
- вакансия, межузельный атом, дислокационная петля/стэкинг‑фолт: такие объекты чувствительны к корректности многочастичных потенциалов и к корректности neighbor‑логики.

## Зональные Verlet‑структуры и MPI‑обмен: как довести прототип до полной TD‑схемы диссертации

### Что в текущем прототипе уже согласуется с диссертационным TD
В диссертационных источниках по методу декомпозиции времени фигурируют:
- разбиение модели на расчётные зоны вдоль оси (упоминается разбиение вдоль Z и соответствующий рисунок), citeturn18search0
- последовательности/типы зон и их прохождение через состояния в ходе конвейерного расчёта (видны обозначения вида `S...d`, `S...p`, и т.п. в диссертационном тексте), citeturn27search1
- использование параметризации порядка `2P` в контексте разбиения/организации вычислений. citeturn28search2

В TDMD‑TD v1.4 уже есть:
- **пять типов зон** (F/D/P/W/S) как устойчивый “алфавит” управления,
- кольцевой обмен зон между процессами,
- вычисление p‑окрестности зоны и использование локальной структуры соседей,
- механизм удержания overlap‑атомов как аналога halo/ghost.

### Где прототип пока расходится с “полным TD” и как это исправлять
Ниже — ключевые улучшения, которые, по сути, превращают “рабочий код” в “реализованный метод”.

#### Формальная машина состояний зон
Сейчас состояние зоны меняется “по месту” в циклах вычисления/обмена. Для строгой TD‑реализации нужна явная машина состояний (FSM), где:

- **Состояния**: `F, D, P, W, S`
- **События**:
  - `recv(zone)` → D
  - `need_neighbors(zone)` → перевод соседних зон D→P
  - `compute_started(zone)` → W
  - `compute_done(zone)` → S
  - `send(zone)` → F или D (если оставлен overlap)

Пример целевой FSM‑диаграммы (логическая, без привязки к конкретному коду):

```
      recv
  F ---------> D -----> W -----> S -----> (send) -----> F
                \        \        \
                 \        \        +--> (keep overlap) -> D
                  +--> P --+
                      ^
                      |
              neighbor_needed
```

Почему это важно:
- можно доказуемо контролировать, что зона не “проскочит” вычисление,
- можно сделать **детерминированный scheduler** и сравнивать его с диссертационной последовательностью.

#### Локальные “таблицы соседей” на уровне зон
Сейчас есть локальные bins‑структуры, но нет чёткого разделения:
- “структура для вычисления сил”,
- “структура для overlap‑решения и MPI‑фильтрации”,
- “структура для будущих многотельных потенциалов”.

Для полной TD‑схемы рекомендуется выделить слой **ZoneNeighborModel** с контрактом:
- `build(candidates, rc, skin)`
- `query(atom_id) -> neighbor_candidates`
- `needs_rebuild(max_disp, step) -> bool`

И обеспечить, чтобы overlap‑решение и вычисление сил использовали **одну и ту же** версию `rc/skin` (иначе возможны рассогласования и пропуски пар).

Здесь можно напрямую опереться на общепринятую практику:
- neighbor cutoff = cutoff + skin,
- перестройка при смещении > skin/2. citeturn25search0turn25search15

#### Улучшение MPI‑обмена
Текущая схема корректна как прототип, но для приближения к “продукционному” TD:
- отказаться от частого `Iprobe` в пользу заранее выделенных `Irecv` буферов (кольцевые обмены хорошо ложатся на persistent requests),
- заменить Python‑уровневые `set`/маски на компактные булевы/битовые маски или сортированные массивы (это важно для производительности),
- определить **единый формат пакета зоны** (структура, порядок, dtype) и версионировать её (для совместимости при рестартах и регресс‑тестах).

#### Временная часть TD (если в диссертации предполагаются временные лаги)
Если целевая TD‑схема подразумевает, что разные MPI‑процессы работают на разных “временных слоях” (конвейер по времени), то потребуется:
- ввести для каждой зоны явный **timestamp/step_id**, который движется вместе с зоной;
- пересчитать формулу buffer/skin так, чтобы она покрывала максимальный временной лаг между зонами, участвующими в взаимодействии;
- расширить тестовый протокол: сравнивать не только совпадение координат, но и совпадение статистик (энергия/pressure) при различных `P`.

Здесь главная научная сложность — обеспечить корректность сил при рассогласованных временных слоях; это “сердце” TD‑метода и должно быть подтверждено строгими тестами и оценкой ошибок.

## Поддержка EAM: требования, форматы, смеси и тесты валидации

### Минимальные требования к EAM в TDMD‑TD
EAM в классической постановке (Daw–Baskes) моделирует энергию как сумму:
- embedding‑энергии \(F(\rho_i)\),
- парных вкладов \(\phi(r_{ij})\),
где \(\rho_i\) — локальная электронная плотность от соседей. citeturn23search2turn23search10

Минимально корректная реализация должна включать:
- чтение табличных данных потенциала,
- интерполяцию по \(r\) и \(\rho\) (обычно сплайны или высококачественная кусочно‑полиномиальная интерполяция),
- вычисление \(\rho_i\) и производных \(F'(\rho_i)\),
- двухпроходную схему:
  1) сбор плотностей,
  2) расчёт сил.

### Табличные форматы и поддержка смесей
На практике наиболее полезно сразу поддержать форматы, совместимые с LAMMPS:
- **funcfl** (один элемент, `pair_style eam`), citeturn23search9
- **setfl / eam.alloy** (многоэлементный файл, `pair_style eam/alloy`), citeturn23search1
- опционально: **eam.fs** (Finnis/Sinclair‑вариант, `pair_style eam/fs`). citeturn23search1

Ключевые требования для смесей:
- маппинг “атомный тип → элемент”, включая возможность “NULL” (в LAMMPS это применяется в hybrid‑схемах). citeturn23search1
- явное хранение функций для пар элементов (в setfl/FS‑форматах), без неявных mixing rules.

### Валидационные тесты EAM на металлах и дефектах
Для EAM недостаточно “запустилось без NaN”. Нужны верифицируемые материалы‑тесты:

**Базовые свойства кристалла (0 K / low T)**
- параметр решётки \(a_0\),
- когезионная энергия \(E_{coh}\),
- упругие константы \(C_{11},C_{12},C_{44}\),
- энергия вакансии (vacancy formation energy).
Именно этот набор Daw & Baskes приводят как целевые свойства, которые EAM способен воспроизводить. citeturn23search2

**Дефекты и “неравновесные” структуры**
Потенциалы Мишина и др. часто валидируются на:
- вакансия/межузельный,
- поверхности,
- stacking fault energy,
- энергию границ зёрен,
- устойчивость разных локальных конфигураций.
Для меди/никеля удобно использовать референсы из репозиториев потенциалов и OpenKIM (как источник эталонных потенциалов и набора тестов). citeturn23search7turn23search19turn23search3

**Тесты “на динамику”**
- сохранение энергии в NVE при малом dt,
- стабильность кристалла при заданной температуре,
- корректность давления/напряжений (вириал) — особенно важно для EAM, поскольку тензор напряжений должен учитывать многочастичные вклады (в LAMMPS это обсуждается в контексте вычисления вириала для many‑body). citeturn24search1turn25search21

## Сводная таблица задач и дорожная карта дальнейшей разработки

### Сравнительная таблица: выполнено vs в работе
| Направление | Статус в v1.4 | Что именно есть сейчас | Что требуется добавить | Сложность | Приоритет |
|---|---|---|---|---:|---:|
| Строгая верификация | Частично | `serial` и `td_local` + `verify` по `max|dr|`, `max|dv|` | Энергия/температура/давление/импульс, допуски, PBC‑корректные ошибки, регресс‑набор тестов | Средняя | Очень высокий |
| Зональные Verlet / neighbor‑структуры | В основном сделано (в виде bins+skin) | Persist‑кэш, локальный z‑интервал (unwrapped), обновление по смещению | Унифицированный слой “ZoneNeighborModel”, согласование overlap и сил, профилирование и оптимизация | Средняя–высокая | Высокий |
| MPI‑обмен зон (TD‑конвейер) | Базовая реализация есть | `td_full_mpi`, scatter, ring exchange, odd/even порядок, overlap‑фильтр | FSM‑планировщик, persistent comm, снижение Python overhead, явные инварианты/доказуемость, возможно time‑lag слой | Высокая | Очень высокий |
| Соответствие TD‑схеме диссертации | Частично | Есть зоны и типы зон, конвейерная идея | Формальная FSM, строгие условия буфера/skin, возможно time‑layer pipeline | Высокая | Очень высокий |
| EAM потенциал | Не сделано | — | Чтение setfl/funcfl, интерполяция, 2‑pass (ρ затем силы), смеси, тесты на решётках/дефектах | Очень высокая | Высокий (после верификации) |
| Давление/вириал | Не сделано | — | Реализация pressure tensor/virial (парные + many‑body позже), тесты на газ/жидкость/кристалл | Высокая | Высокий |
| Инфраструктура тестов | Не сделано | — | pytest/CI, эталонные конфиги, “золотые” траектории/статистики | Средняя | Высокий |
| Производительность | Частично | локальные bins уменьшают O(N²) | профилирование, NumPy‑векторизация/Numba/Cython, уменьшение аллокаций | Средняя–высокая | Средний |

### Дорожная карта: ближайшие конкретные шаги
Ниже — план, который максимизирует научную надёжность и минимизирует риск “строить на неверном основании”.

**Шаг A: превратить `verify` в строгий валидационный стенд (самый высокий приоритет)**
- Добавить вычисление **U, K, E**, температуры, импульса, и простейшего давления (вириал для парных потенциалов).
- Добавить PBC‑корректную метрику ошибки координат (minimum image).
- Сделать тестовые сценарии: газ / LJ‑флюид / FCC / BCC.
- Зафиксировать допускаемые пороги ошибок и дрейфа энергии (для заданных dt и N шагов), опираясь на стандартные представления об устойчивости интегратора/дрейфе энергии. citeturn23search28turn23search12

**Шаг B: формализовать TD‑схему через явную машину состояний зон**
- Вынести FSM в отдельный модуль, сделать таблицу переходов и лог событий.
- Обеспечить, чтобы сила/overlap/MPI работали по единому state‑контракту.
- Это позволит “привязать” реализацию к диссертационной логике типов зон и последовательностей расчёта (см. упоминания последовательностей зон в диссертационных материалах). citeturn27search1turn18search0

**Шаг C: оптимизировать MPI‑обмен и убрать Python‑узкие места**
- Перейти к persistent `Isend/Irecv` там, где паттерн фиксирован.
- Упростить критерии получения сообщений (минимизировать `Iprobe`‑скан по всем зонам).
- Убрать Python `set` из overlap‑критичного пути.

**Шаг D: только после A–C — внедрять EAM**
- Начать с `eam/alloy setfl` как наиболее практичного для смесей (и верифицируемого по LAMMPS‑референсам формата). citeturn23search1turn23search13
- Валидация на одном металле (например Cu или Ni) с потенциалом из репозитория (NIST/OpenKIM), затем расширение на сплавы. citeturn23search7turn23search3turn23search19
- После прохождения решёточных тестов — дефектные тесты.

### Наглядные схемы

**Архитектура v1.4 (логическая)**

```
YAML config
   |
init r,v  ---------+
   |               |
   v               v
Zone layout (1D z)  Serial reference (cell-list)
   |
   v
(Per zone, per step)
  candidate_ids from p-neighborhood
        |
        v
  PersistentZoneLocalZBinsCache  (local z unwrapped)
        |
        v
  forces_on_targets_zonecells  ->  velocity-Verlet update
        |
        v
  assign_atoms_to_zones  (update zone memberships)
        |
        v
MPI TD exchange (td_full_mpi):
  send zone payload -> next_rank
  recv zone payload <- prev_rank
  overlap filter (keep halo atoms)
```

**Рекомендуемая целевая FSM‑логика зон (для реализации “TD как в диссертации”)**

```
F (empty) --recv--> D (ready)
D --start compute--> W (working)
W --done--> S (sendable)
S --send--> F (or D if keep overlap)
D --neighbor needed--> P (p-neighborhood participant)
P --when used--> D
```

Эта формализация делает поведение воспроизводимым и сопоставимым с диссертационными схемами “типов зон/состояний” в конвейере. citeturn27search1turn18search0
