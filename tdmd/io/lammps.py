from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
import os
import numpy as np

from .task import Task, TaskAtom
from ..potentials import canonical_potential_kind, parse_pair_coeffs, ensure_pair_coeffs_complete

@dataclass(frozen=True)
class LammpsData:
    xlo: float
    xhi: float
    ylo: float
    yhi: float
    zlo: float
    zhi: float
    masses: dict[int, float]
    atoms: list[TaskAtom]

def _atom_style(task: Task) -> str:
    has_charge = any(a.charge is not None for a in task.atoms)
    return "charge" if has_charge else "atomic"


def _sorted_task_types(task: Task) -> list[int]:
    types = sorted(set(int(a.type) for a in task.atoms))
    if not types:
        raise ValueError("task has no atom types")
    max_type = int(types[-1])
    expected = list(range(1, max_type + 1))
    if types != expected:
        raise ValueError(
            "LAMMPS export requires contiguous atom types starting from 1; "
            f"got {types}"
        )
    return types


def _ensemble_fix_lines(task: Task) -> list[str]:
    ens = task.ensemble
    if ens.kind == "nve":
        return ["fix tdmd_int all nve"]
    if ens.kind == "nvt":
        if ens.thermostat is None:
            raise ValueError("ensemble.kind=nvt requires thermostat")
        t_target = float(ens.thermostat.params.get("t_target", 1.0))
        tau_t = float(ens.thermostat.params.get("tau", max(task.dt, 1e-6)))
        return [f"fix tdmd_int all nvt temp {t_target:.8f} {t_target:.8f} {tau_t:.8f}"]
    if ens.kind == "npt":
        if ens.thermostat is None or ens.barostat is None:
            raise ValueError("ensemble.kind=npt requires thermostat and barostat")
        t_target = float(ens.thermostat.params.get("t_target", 1.0))
        tau_t = float(ens.thermostat.params.get("tau", max(task.dt, 1e-6)))
        p_target = float(ens.barostat.params.get("p_target", 0.0))
        tau_p = float(ens.barostat.params.get("tau", max(task.dt, 1e-6)))
        return [
            f"fix tdmd_int all npt temp {t_target:.8f} {t_target:.8f} {tau_t:.8f} "
            f"iso {p_target:.8f} {p_target:.8f} {tau_p:.8f}"
        ]
    raise ValueError(f"unsupported ensemble.kind: {ens.kind}")

def export_lammps_data(task: Task, path: str) -> str:
    atoms = sorted(task.atoms, key=lambda a: a.id)
    types = _sorted_task_types(task)
    masses = {}
    for t in types:
        mset = {float(a.mass) for a in atoms if int(a.type) == t}
        if len(mset) != 1:
            raise ValueError(f"inconsistent mass for atom type {t}: {sorted(mset)}")
        masses[t] = float(mset.pop())

    style = _atom_style(task)
    xlo, xhi = 0.0, float(task.box.x)
    ylo, yhi = 0.0, float(task.box.y)
    zlo, zhi = 0.0, float(task.box.z)

    lines = []
    lines.append("LAMMPS data file generated by tdmd\n\n")
    lines.append(f"{len(atoms)} atoms\n")
    lines.append(f"{len(types)} atom types\n\n")
    lines.append(f"{xlo:.8f} {xhi:.8f} xlo xhi\n")
    lines.append(f"{ylo:.8f} {yhi:.8f} ylo yhi\n")
    lines.append(f"{zlo:.8f} {zhi:.8f} zlo zhi\n\n")
    lines.append("Masses\n\n")
    for t in types:
        lines.append(f"{t} {masses[t]:.8f}\n")
    lines.append("\n")
    lines.append(f"Atoms # {style}\n\n")
    for a in atoms:
        if style == "charge":
            q = 0.0 if a.charge is None else float(a.charge)
            lines.append(f"{a.id} {a.type} {q:.8f} {a.r[0]:.8f} {a.r[1]:.8f} {a.r[2]:.8f}\n")
        else:
            lines.append(f"{a.id} {a.type} {a.r[0]:.8f} {a.r[1]:.8f} {a.r[2]:.8f}\n")
    lines.append("\n")
    lines.append("Velocities\n\n")
    for a in atoms:
        lines.append(f"{a.id} {a.v[0]:.8f} {a.v[1]:.8f} {a.v[2]:.8f}\n")
    text = "".join(lines)
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)
    return path

def export_lammps_in(task: Task, path: str, data_filename: str = "data.lammps") -> str:
    units = task.units
    atom_style = _atom_style(task)
    bflags = ["p" if b else "f" for b in task.box.pbc]
    boundary = " ".join(bflags)
    cutoff = float(task.cutoff)
    dt = float(task.dt)
    steps = int(task.steps)
    pot = canonical_potential_kind(task.potential.kind)
    params = task.potential.params
    type_ids = _sorted_task_types(task)

    pair_lines = []
    if pot == "lj":
        eps = float(params.get("epsilon", 1.0))
        sigma = float(params.get("sigma", 1.0))
        pair_coeffs = parse_pair_coeffs("lj", params)
        ensure_pair_coeffs_complete(pair_coeffs, np.asarray(type_ids, dtype=np.int32))
        pair_lines.append(f"pair_style lj/cut {cutoff:.8f}")
        if pair_coeffs:
            for i, ti in enumerate(type_ids):
                for tj in type_ids[i:]:
                    prm = pair_coeffs[(int(ti), int(tj))]
                    pair_lines.append(
                        f"pair_coeff {ti} {tj} {float(prm['epsilon']):.8f} {float(prm['sigma']):.8f}"
                    )
        else:
            pair_lines.append(f"pair_coeff * * {eps:.8f} {sigma:.8f}")
    elif pot == "morse":
        D_e = float(params.get("D_e", 0.29614))
        a = float(params.get("a", 1.11892))
        r0 = float(params.get("r0", 3.29692))
        pair_coeffs = parse_pair_coeffs("morse", params)
        ensure_pair_coeffs_complete(pair_coeffs, np.asarray(type_ids, dtype=np.int32))
        pair_lines.append(f"pair_style morse {cutoff:.8f}")
        if pair_coeffs:
            for i, ti in enumerate(type_ids):
                for tj in type_ids[i:]:
                    prm = pair_coeffs[(int(ti), int(tj))]
                    pair_lines.append(
                        f"pair_coeff {ti} {tj} {float(prm['D_e']):.8f} {float(prm['a']):.8f} {float(prm['r0']):.8f}"
                    )
        else:
            pair_lines.append(f"pair_coeff * * {D_e:.8f} {a:.8f} {r0:.8f}")
    elif pot == "table":
        table_file = params.get("file")
        keyword = params.get("keyword")
        table_style = params.get("style", "linear 1000")
        if not table_file or not keyword:
            raise ValueError("table potential requires params.file and params.keyword")
        pair_lines.append(f"pair_style table {table_style}")
        pair_lines.append(f"pair_coeff * * {table_file} {keyword}")
    elif pot == "eam/alloy":
        setfl_file = str(params.get("file", "")).strip()
        elems = params.get("elements")
        if not setfl_file:
            raise ValueError("eam/alloy potential requires params.file")
        if not isinstance(elems, (list, tuple)) or not elems:
            raise ValueError("eam/alloy potential requires non-empty params.elements list")
        if len(elems) < len(type_ids):
            raise ValueError(
                f"eam/alloy params.elements length ({len(elems)}) "
                f"is smaller than atom types count ({len(type_ids)})"
            )
        # LAMMPS expects one element token per atom type (1..Ntypes) after setfl path.
        elem_tokens = [str(elems[t - 1]).strip() for t in type_ids]
        if any(not x for x in elem_tokens):
            raise ValueError("eam/alloy params.elements contains empty element name")
        pair_lines.append("pair_style eam/alloy")
        pair_lines.append(f"pair_coeff * * {setfl_file} {' '.join(elem_tokens)}")
    else:
        raise ValueError(f"unsupported potential kind: {pot}")

    dump_every = max(1, min(steps, 10))
    fix_lines = _ensemble_fix_lines(task)

    lines = [
        f"units {units}\n",
        f"atom_style {atom_style}\n",
        f"boundary {boundary}\n",
        f"read_data {data_filename}\n",
        "\n",
    ]
    for pl in pair_lines:
        lines.append(pl + "\n")
    lines.extend([
        f"timestep {dt:.8f}\n",
        "neighbor 2.0 bin\n",
    ])
    for fl in fix_lines:
        lines.append(fl + "\n")
    lines.extend([
        f"dump 1 all custom {dump_every} traj.lammpstrj id type x y z vx vy vz\n",
        f"run {steps}\n",
        "unfix tdmd_int\n",
    ])
    text = "".join(lines)
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)
    return path

def _strip_comment(line: str) -> str:
    if "#" in line:
        return line.split("#", 1)[0].strip()
    return line.strip()

def import_lammps_data(path: str) -> LammpsData:
    with open(path, "r", encoding="utf-8") as f:
        raw = [ln.rstrip("\n") for ln in f]

    # header scan
    xlo = xhi = ylo = yhi = zlo = zhi = None
    style_hint = None
    masses: dict[int, float] = {}
    atoms: dict[int, TaskAtom] = {}
    velocities: dict[int, tuple[float, float, float]] = {}

    section = None
    for line in raw:
        ln = line.strip()
        if not ln:
            continue
        if ln.lower().startswith("atoms"):
            # "Atoms # atomic" or similar
            if "#" in ln:
                style_hint = ln.split("#", 1)[1].strip().split()[0].lower()
            section = "Atoms"
            continue
        if ln.lower().startswith("velocities"):
            section = "Velocities"
            continue
        if ln.lower().startswith("masses"):
            section = "Masses"
            continue
        if any(k in ln for k in ("xlo", "xhi")) and "xlo" in ln and "xhi" in ln:
            parts = _strip_comment(ln).split()
            if len(parts) >= 2:
                xlo, xhi = float(parts[0]), float(parts[1])
            continue
        if any(k in ln for k in ("ylo", "yhi")) and "ylo" in ln and "yhi" in ln:
            parts = _strip_comment(ln).split()
            if len(parts) >= 2:
                ylo, yhi = float(parts[0]), float(parts[1])
            continue
        if any(k in ln for k in ("zlo", "zhi")) and "zlo" in ln and "zhi" in ln:
            parts = _strip_comment(ln).split()
            if len(parts) >= 2:
                zlo, zhi = float(parts[0]), float(parts[1])
            continue
        if section == "Masses":
            parts = _strip_comment(ln).split()
            if len(parts) >= 2:
                masses[int(parts[0])] = float(parts[1])
            continue
        if section == "Atoms":
            parts = _strip_comment(ln).split()
            if not parts:
                continue
            if style_hint == "charge":
                if len(parts) < 6:
                    continue
                aid = int(parts[0]); atype = int(parts[1]); charge = float(parts[2])
                r = (float(parts[3]), float(parts[4]), float(parts[5]))
            else:
                if len(parts) < 5:
                    continue
                aid = int(parts[0]); atype = int(parts[1]); charge = None
                r = (float(parts[2]), float(parts[3]), float(parts[4]))
            mass = float(masses.get(atype, 0.0))
            atoms[aid] = TaskAtom(id=aid, type=atype, mass=mass, charge=charge, r=r, v=(0.0, 0.0, 0.0))
            continue
        if section == "Velocities":
            parts = _strip_comment(ln).split()
            if len(parts) >= 4:
                aid = int(parts[0])
                velocities[aid] = (float(parts[1]), float(parts[2]), float(parts[3]))
            continue

    if None in (xlo, xhi, ylo, yhi, zlo, zhi):
        raise ValueError("failed to parse box bounds from LAMMPS data file")
    if not masses:
        raise ValueError("failed to parse Masses section")
    if not atoms:
        raise ValueError("failed to parse Atoms section")

    # attach velocities
    out_atoms: list[TaskAtom] = []
    for aid in sorted(atoms.keys()):
        a = atoms[aid]
        v = velocities.get(aid, (0.0, 0.0, 0.0))
        mass = float(masses.get(int(a.type), a.mass))
        out_atoms.append(TaskAtom(id=a.id, type=a.type, mass=mass, charge=a.charge, r=a.r, v=v))

    return LammpsData(
        xlo=float(xlo), xhi=float(xhi),
        ylo=float(ylo), yhi=float(yhi),
        zlo=float(zlo), zhi=float(zhi),
        masses=masses,
        atoms=out_atoms,
    )
